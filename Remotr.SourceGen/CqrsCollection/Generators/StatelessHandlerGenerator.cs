using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Remotr.SourceGen.CqrsCollection.Utils;
using Remotr.SourceGen.CqrsCollection.Validators;
using System.Collections.Generic;
using System.Text;

namespace Remotr.SourceGen.CqrsCollection.Generators;

/// <summary>
/// Generates stateless handler code.
/// </summary>
public class StatelessHandlerGenerator
{
    private readonly CommandHandlerGenerator _commandHandlerGenerator;
    private readonly QueryHandlerGenerator _queryHandlerGenerator;
    private readonly HandlerTypeValidator _handlerTypeValidator;

    /// <summary>
    /// Initializes a new instance of the <see cref="StatelessHandlerGenerator"/> class.
    /// </summary>
    public StatelessHandlerGenerator()
    {
        _commandHandlerGenerator = new CommandHandlerGenerator();
        _queryHandlerGenerator = new QueryHandlerGenerator();
        _handlerTypeValidator = new HandlerTypeValidator();
    }

    /// <summary>
    /// Generates a stateless handler for the given interface and handler type.
    /// </summary>
    /// <param name="interfaceDeclaration">The interface declaration</param>
    /// <param name="handlerTypeSymbol">The handler type symbol</param>
    /// <param name="alias">The alias</param>
    /// <param name="compilation">The compilation</param>
    /// <param name="context">The source production context</param>
    public void Generate(
        InterfaceDeclarationSyntax interfaceDeclaration, 
        ITypeSymbol handlerTypeSymbol, 
        string alias,
        Compilation compilation,
        SourceProductionContext context)
    {
        var handlerName = handlerTypeSymbol.Name;
        var isCommandHandler = _handlerTypeValidator.IsCommandHandler(handlerTypeSymbol);
        var genericTypeArgs = TypeUtils.GetGenericTypeArguments(handlerTypeSymbol);
        
        if (genericTypeArgs.Count == 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "REMOTR008",
                        "Could not determine generic type arguments",
                        "Could not determine generic type arguments for handler type '{0}'",
                        "Remotr",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    interfaceDeclaration.GetLocation(),
                    handlerTypeSymbol.Name));
            return;
        }

        // Get namespace and interface name
        var namespaceName = TypeUtils.GetNamespace(interfaceDeclaration);
        var interfaceName = interfaceDeclaration.Identifier.Text;

        // Build stateless handler
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// This file was generated by the Remotr.SourceGen CqrsCollectionGenerator.");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Threading.Tasks;");
        sourceBuilder.AppendLine("using Remotr;");
        sourceBuilder.AppendLine();
        
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sourceBuilder.AppendLine($"namespace {namespaceName};");
            sourceBuilder.AppendLine();
        }

        // First generic parameter is the state type, we need to extract the others
        var stateType = genericTypeArgs[0].ToString();
        
        // Create the appropriate stateless handler class
        if (isCommandHandler)
        {
            GenerateCommandHandler(sourceBuilder, interfaceName, alias, handlerName, stateType, genericTypeArgs);
        }
        else // QueryHandler
        {
            GenerateQueryHandler(sourceBuilder, interfaceName, alias, handlerName, stateType, genericTypeArgs);
        }

        context.AddSource($"{alias}.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    private void GenerateCommandHandler(
        StringBuilder sourceBuilder, 
        string interfaceName, 
        string className, 
        string statefulHandlerName, 
        string stateType, 
        List<ITypeSymbol> genericTypeArgs)
    {
        switch (genericTypeArgs.Count)
        {
            case 1: // StatefulCommandHandler<TState>
                _commandHandlerGenerator.GenerateNoInputNoOutput(sourceBuilder, interfaceName, className, statefulHandlerName, stateType);
                break;
            case 2: // StatefulCommandHandler<TState, TOutput>
                _commandHandlerGenerator.GenerateNoInputWithOutput(sourceBuilder, interfaceName, className, statefulHandlerName, stateType, genericTypeArgs[1].ToString());
                break;
            case 3: // StatefulCommandHandler<TState, TInput, TOutput>
                _commandHandlerGenerator.GenerateWithInputAndOutput(sourceBuilder, interfaceName, className, statefulHandlerName, stateType, genericTypeArgs[1].ToString(), genericTypeArgs[2].ToString());
                break;
        }
    }

    private void GenerateQueryHandler(
        StringBuilder sourceBuilder, 
        string interfaceName, 
        string className, 
        string statefulHandlerName, 
        string stateType, 
        List<ITypeSymbol> genericTypeArgs)
    {
        switch (genericTypeArgs.Count)
        {
            case 1: // StatefulQueryHandler<TState>
                _queryHandlerGenerator.GenerateNoOutput(sourceBuilder, interfaceName, className, statefulHandlerName, stateType);
                break;
            case 2: // StatefulQueryHandler<TState, TOutput>
                _queryHandlerGenerator.GenerateWithOutput(sourceBuilder, interfaceName, className, statefulHandlerName, stateType, genericTypeArgs[1].ToString());
                break;
            case 3: // StatefulQueryHandler<TState, TInput, TOutput>
                _queryHandlerGenerator.GenerateWithInputAndOutput(sourceBuilder, interfaceName, className, statefulHandlerName, stateType, genericTypeArgs[1].ToString(), genericTypeArgs[2].ToString());
                break;
        }
    }
} 